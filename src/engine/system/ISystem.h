#pragma once

#include <cassert>
#include <fstream>

#include "engine/Config.h"
#include "engine/message/Message.h"
#include "engine/system/script/ScriptBindingSet.h"

#include "engine/entity/ComponentStore.h"

namespace ds
{
/**
 * Interface for all systems to be processed by the engine.
 *
 * A system is any set of related functionality that needs to be updated by the
 * engine every game tick. More specifically, systems consist of high-level
 * functionality. For lower level systems, the IFrameworkSystem interface
 * exists.
 */
class ISystem
{
public:
    ISystem() : m_accumBuffer(0), m_componentStore(nullptr)
    {
    }

    /**
     * Virtual destructor. Required so that the destructor of derived classes is
     * called properly.
     */
    virtual ~ISystem()
    {
    }

    /**
     * Perform any necessary initialization of the system
     *
     * If initialization fails, method should return FALSE, otherwise TRUE.
     *
     * @post   Passed config file contents is only valid for the lifetime of the
     * Initialize call. Do not attempt to hold onto it.
     *
     * @param   configFile   const char *, config file contents.
     * @return               bool, TRUE if initialization succeeds, FALSE
     * otherwise.
     */
    virtual bool Initialize(const char *configFile) = 0;

    /**
     * Update the system over the given timestep.
     *
     * @param  deltaTime  float, timestep to update the system over.
     */
    virtual void Update(float deltaTime) = 0;

    /**
     * Perform any teardown of the system.
     */
    virtual void Shutdown() = 0;

    /**
     * Post messages for system to handle.
     *
     * Messages may be handled in this method but it is recommended that the
     * handling of messages is deferred until the Update() call. You could
     * achieve this by storing the events in a local MessageStream and then
     * processing them in the Update() call.
     *
     * @param  messages  const ds_msg::MessageStream &messages, messages to send
     * to this class.
     */
    virtual void PostMessages(const ds_msg::MessageStream &messages) = 0;

    /**
     * Collect messages generated by this system.
     *
     * It is assumed that once this message is called the messages are no longer
     * needed, thus you can sefely purge any generated events after this method
     * has been called.
     *
     * @return  ds_msg::MessageStream, stream of messages generated by this
     * system.
     */
    virtual ds_msg::MessageStream CollectMessages() = 0;

    /**
     * Get the name of the system. This name is used in the script system of the
     * engine, a pointer to the system is placed in a Lua global with the name
     * '__GetNameResult' (i.e. two underscores prepended to the result of this
     * function).
     *
     * @post   Returned name is unique among systems added to the engine.
     *
     * @return   const char *, name string.
     */
    virtual const char *GetName() const = 0;

    /**
     * Optionally return any required script bindings.
     *
     * @return  ScriptBindingSet, the script bindings the system wants to
     * register with the Script system.
     */
    virtual ScriptBindingSet GetScriptBindings() const
    {
        return ScriptBindingSet();
    }

    /**
     * Gets the rate at which the system should be updated.
     * If the returned value is 0, the system will be updated as often as
     * possible.
     * @param screenRefreshRate The refreshrate of the current monitor.
     * @return The desired update rate
     */
    virtual unsigned getUpdateRate(uint32_t screenRefreshRate) const
    {
        return 0;
    }

    /**
     * Gets the number of consecutive updates, used when system falls behind on
     * updates.
     * For example:
     *   Rendering took longer than normal.
     *   Physics is allowed to catch up by updating multiple times, keeping
     * realtime.
     * If the returned value is 0, then there is an unlimited number of
     * consecutive updates.
     * @return The max number of consecutive updates
     * @remarks On systems that may lag behind on updates, this should not
     * return 0. Otherwise an infinite loop may be entered.
     */
    virtual unsigned getMaxConsecutiveUpdates() const
    {
        return 0;
    }

    /**
     * Getter access to the internal update time accumulation buffer.
     * @return The amount of time the system has "saved up" from updates.
     */
    float getUpdateAccum()
    {
        return m_accumBuffer;
    }

    /**
     * Sets the internal update time accumulation buffer.
     * @param accum The amount of time the system has "saved up" from updates.
     */
    void setUpdateAccum(float accum)
    {
        m_accumBuffer = accum;
    }

    /**
      * Set the component store this system has access to.
      *
      * @param   componentStore   ComponentStore &, structure where all
      * components are kept.
      */
    void SetComponentStore(ComponentStore *componentStore)
    {
        m_componentStore = componentStore;
    }

protected:
    /**
     * Get the component store.
     *
     * @return   ComponentStore &, component store.
     */
    ComponentStore &GetComponentStore()
    {
        assert(m_componentStore != nullptr);

        return *m_componentStore;
    }

    /**
     * Get the component store.
     *
     * @return   const ComponentStore &, component store.
     */
    const ComponentStore &GetComponentStore() const
    {
        assert(m_componentStore != nullptr);

        return *m_componentStore;
    }

private:
    /** Contains the accumulated delta time for this system **/
    float m_accumBuffer;

    /** Pointer to where all components in the engine are stored. */
    ComponentStore *m_componentStore;
};
}
