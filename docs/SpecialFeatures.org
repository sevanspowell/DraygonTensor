* Special Features

- Mention CMake cross-platform build
- Lua script components and parameters
- Blender export stuff
- Data files, data-driven development
- 

** Data-driven design

** Blender plugin 

Because the engine is almost completely data-driven, we were able to write some
external tools to more easily produce the data we needed for our game. One of
the tools we used was Blender.

Blender exposes much of it's functionality via a Python scripting interface, we
developed a number of Python modules to add some additional functionality to
Blender.

*** The export script

We wrote a script that takes an entire scene in Blender and outputs it in a
format our game engine expects. A .prefab file is created for each object in the
scene and a .lua file is created which spawns each of these .prefab files. Also,
.material, .texture and .mesh files are outputted and any assets needed to run
the game are exported from Blender to the export location.

#+NAME: src/blender/addons/io_draygon/__init__.py 
#+BEGIN_SRC python
...
def writeAll(context, folderpath, levelpath):

    # Open lua level file
    levelout = open(levelpath, 'w')
    levelname = os.path.splitext(os.path.split(levelpath)[1])[0]
    # Create level loading file
    levelout.write("function " + levelname + "(offset)\n")

    # For each object in the scene
    scene = bpy.context.scene
    for obj in scene.objects:
        if (obj.type == 'MESH'):
            ...
            # Output necessary data files 
            reltexturepath = writeObjectTexture(obj, folderpath)
            relmaterialpath = writeObjectMaterial(obj, folderpath, reltexturepath)
            relmeshpath = writeObjectMesh(obj, folderpath)
            relprefabpath = writePrefab(obj, folderpath, relmeshpath, relmaterialpath)

            # Ensure the object is spawned in the correct place 
            position = "Vector3(" + str(obj.location.x) + ", " + str(obj.location.z) + ", " + str(-obj.location.y) + ")"
            scale = "Vector3(" + str(obj.scale.x) + ", " + str(obj.scale.z) + ", " + str(obj.scale.y) + ")"
            orientation = obj.rotation_euler.to_quaternion()

            orientation = "Quaternion(" + str(orientation[1]) + ", " + str(orientation[3]) + ", " + str(-orientation[2]) + ", " + str(orientation[0]) + ")"

            levelout.write(luatab + "local location = " + position + "\n")
            levelout.write(luatab + "if offset ~= nil then\n")
            levelout.write(luatab + luatab + "location = location + offset\n")
            levelout.write(luatab + "end\n")
            levelout.write(luatab + "Script.spawn_prefab(\"" + os.path.splitext(relprefabpath)[0] + "\", location" + ", " + orientation + ", " + scale + ")\n")

    # Finish level file
    levelout.write("end")
    levelout.close()

    return {'FINISHED'}
...
#+END_SRC

All the user has to do to spawn all these prefabs in the world is include the
created .lua file in their boot script and call the appropriate method. For
example:

#+NAME: boot.lua
#+BEGIN_SRC lua 
require 'GymProgressBackUp8'

function preinit()
    ...
    GymProgressBackUp8()
    ...
end
#+END_SRC

Will spawn the entire gym scene in the game.

*** The affordance plugin

Affordances (for those objects that have them) are also exported using the
Blender export script. However, Blender does not natively have any concept of
affordances for objects. We added this ability to Blender using the Python
scripting API.

We created a field that allows users to add affordances and their value for each
object in the world. This is pictured below:

~PIC~

These values were then included in the export script.

*** The rigid body plugin 

Blender does have the concept of rigid bodies natively, but not necessarily for
multiple collisions shapes per rigid body, each with their own mass and inertia
tensors. We also needed to add this concept to Blender ourselves.

The result is pictured below:

~PIC~

These values were then included in the export script.
